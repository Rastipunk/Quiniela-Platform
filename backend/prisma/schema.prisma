datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum PlatformRole {
  ADMIN
  HOST
  PLAYER
}

enum UserStatus {
  ACTIVE
  DISABLED
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

model User {
  id           String       @id @default(uuid())
  email        String       @unique
  username     String       @unique
  displayName  String
  passwordHash String
  platformRole PlatformRole @default(PLAYER)
  status       UserStatus   @default(ACTIVE)

  // Comentario en español: campos de perfil del usuario
  firstName   String?
  lastName    String?
  dateOfBirth DateTime?
  gender      Gender?
  bio         String?   @db.VarChar(200)
  country     String?   @db.VarChar(2) // ISO 3166-1 alpha-2 (MX, CO, ES, etc.)
  timezone    String? // IANA timezone (ej: "America/Mexico_City", "Europe/Madrid")

  // Comentario en español: tracking de cambio de username (máximo 1 cada 30 días)
  lastUsernameChangeAt DateTime?

  // Comentario en español: token de reset de password (válido 1 hora)
  resetToken          String?
  resetTokenExpiresAt DateTime?

  // Comentario en español: Google OAuth ID (único por usuario de Google)
  googleId String? @unique

  // =========================================================================
  // EMAIL VERIFICATION
  // Comentario en español: verificación de email para cuentas email/password
  // =========================================================================

  emailVerified                   Boolean   @default(false) // true = email verificado
  emailVerificationToken          String?   @unique // Token único para verificar email
  emailVerificationTokenExpiresAt DateTime? // Expiración del token (24 horas)

  // =========================================================================
  // LEGAL CONSENT TRACKING
  // Comentario en español: campos para tracking de consentimiento legal (GDPR/CCPA compliance)
  // =========================================================================

  // Términos de Servicio
  acceptedTermsAt      DateTime? // Cuándo aceptó TOS
  acceptedTermsVersion String?   // Versión del TOS aceptado (ej: "2026-01-25")

  // Política de Privacidad
  acceptedPrivacyAt      DateTime? // Cuándo aceptó Privacy Policy
  acceptedPrivacyVersion String?   // Versión de Privacy Policy aceptada

  // Consentimiento de marketing (emails promocionales) - OPCIONAL
  marketingConsent   Boolean   @default(false)
  marketingConsentAt DateTime?

  // Confirmación de edad mínima (13+)
  ageVerifiedAt DateTime?

  // =========================================================================
  // EMAIL NOTIFICATION PREFERENCES
  // Comentario en español: preferencias de notificación por email del usuario
  // =========================================================================

  // Master toggle - si false, no recibe ningún email excepto password reset
  emailNotificationsEnabled Boolean @default(true)

  // Preferencias granulares (solo aplican si emailNotificationsEnabled=true)
  emailPoolInvitations     Boolean @default(true) // Invitaciones a pools
  emailDeadlineReminders   Boolean @default(true) // Recordatorios de deadline
  emailResultNotifications Boolean @default(true) // Resultados publicados
  emailPoolCompletions     Boolean @default(true) // Pool completado

  createdAtUtc DateTime     @default(now())
  updatedAtUtc DateTime     @updatedAt
  predictions  Prediction[]

  poolsCreated              Pool[]
  poolMemberships           PoolMember[]
  poolInvitesCreated        PoolInvite[]
  resultVersionsCreated     PoolMatchResultVersion[]
  structuralPredictions     StructuralPrediction[]
  structuralPhaseResults    StructuralPhaseResult[]
  groupStandingsPredictions GroupStandingsPrediction[]
  groupStandingsResults     GroupStandingsResult[]

  @@index([username])
  @@index([resetToken])
  @@index([googleId])
  @@index([emailVerificationToken])
}

model AuditEvent {
  id           String   @id @default(uuid())
  createdAtUtc DateTime @default(now())

  actorUserId String?
  action      String
  entityType  String?
  entityId    String?
  poolId      String?

  dataJson  Json?
  ip        String?
  userAgent String?
}

enum TemplateStatus {
  DRAFT
  PUBLISHED
  DEPRECATED
}

enum TemplateVersionStatus {
  DRAFT
  PUBLISHED
  DEPRECATED
}

model TournamentTemplate {
  id          String  @id @default(uuid())
  key         String  @unique // ej: "worldcup_2026"
  name        String
  description String?

  status TemplateStatus @default(DRAFT)

  // Comentario en español: referencia rápida a la versión publicada actual (si existe)
  currentPublishedVersionId String?                    @unique
  currentPublishedVersion   TournamentTemplateVersion? @relation("CurrentPublishedVersion", fields: [currentPublishedVersionId], references: [id])

  versions TournamentTemplateVersion[]

  // Comentario en español: instancias creadas desde este template
  instances TournamentInstance[]

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt
}

model TournamentTemplateVersion {
  id         String             @id @default(uuid())
  templateId String
  template   TournamentTemplate @relation(fields: [templateId], references: [id])

  // Comentario en español: relación inversa opcional para currentPublishedVersion
  currentForTemplate TournamentTemplate? @relation("CurrentPublishedVersion")

  // Comentario en español: instancias creadas a partir de esta versión publicada
  instances TournamentInstance[] @relation("InstanceSourceVersion")

  versionNumber Int
  status        TemplateVersionStatus @default(DRAFT)

  dataJson       Json
  publishedAtUtc DateTime?

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([templateId, versionNumber])
}

enum TournamentInstanceStatus {
  DRAFT
  ACTIVE
  COMPLETED
  ARCHIVED
}

// =========================================================================
// AUTO RESULTS - Configuración de fuente de resultados automáticos
// =========================================================================

enum ResultSourceMode {
  MANUAL // Host ingresa resultados manualmente (comportamiento existente)
  AUTO   // Resultados se obtienen automáticamente de API externa (API-Football)
}

enum ResultSource {
  HOST_MANUAL      // Host ingresó en instancia MANUAL (comportamiento existente)
  HOST_PROVISIONAL // Host ingresó en instancia AUTO mientras espera resultado de API
  API_CONFIRMED    // Resultado confirmado de API-Football (autoritativo)
  HOST_OVERRIDE    // Host corrigió un resultado de API (errata con reason obligatorio)
}

enum SyncStatus {
  RUNNING
  COMPLETED
  FAILED
  PARTIAL // Algunos fixtures actualizados, otros con errores
}

model TournamentInstance {
  id String @id @default(uuid())

  templateId String
  template   TournamentTemplate @relation(fields: [templateId], references: [id])

  templateVersionId String
  templateVersion   TournamentTemplateVersion @relation("InstanceSourceVersion", fields: [templateVersionId], references: [id])

  name   String
  status TournamentInstanceStatus @default(DRAFT)

  // Comentario en español: snapshot congelado del torneo "real" (copiado desde la versión publicada)
  dataJson Json

  // =========================================================================
  // AUTO RESULTS - Configuración de fuente de resultados automáticos
  // =========================================================================

  // Modo de obtención de resultados: MANUAL (host) o AUTO (API-Football)
  resultSourceMode ResultSourceMode @default(MANUAL)

  // Configuración de API-Football (solo usado si resultSourceMode = AUTO)
  apiFootballLeagueId Int? // ID de liga en API-Football (ej: 1 = World Cup)
  apiFootballSeasonId Int? // Año/temporada en API-Football (ej: 2026)

  // Estado de sincronización
  lastSyncAtUtc DateTime? // Última sincronización exitosa con API-Football
  syncEnabled   Boolean   @default(true) // Kill switch de emergencia para detener sync

  // Relaciones para auto results
  matchMappings    MatchExternalMapping[]
  syncLogs         ResultSyncLog[]
  matchSyncStates  MatchSyncState[]

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt
  pools        Pool[]

  @@index([templateId])
  @@index([templateVersionId])
  @@index([resultSourceMode])
}

enum PoolVisibility {
  PRIVATE
  PUBLIC
}

enum PoolStatus {
  DRAFT
  ACTIVE
  COMPLETED
  ARCHIVED
}

enum PoolMemberRole {
  HOST
  CO_ADMIN
  PLAYER
}

enum PoolMemberStatus {
  PENDING_APPROVAL
  ACTIVE
  LEFT
  BANNED
}

enum ResultVersionStatus {
  PUBLISHED
}

model Pool {
  id String @id @default(uuid())

  tournamentInstanceId String
  tournamentInstance   TournamentInstance @relation(fields: [tournamentInstanceId], references: [id])

  name        String
  description String?

  visibility PoolVisibility @default(PRIVATE)
  status     PoolStatus     @default(DRAFT)

  // Comentario en español: zona horaria del pool (IANA), ej: "America/Bogota"
  timeZone String @default("UTC")

  // Comentario en español: cierre de pronósticos X minutos antes del kickoff
  deadlineMinutesBeforeKickoff Int    @default(10)
  scoringPresetKey             String @default("CLASSIC")

  // Comentario en español: habilita avance automático de fases cuando se completan resultados
  autoAdvanceEnabled Boolean @default(true)

  // Comentario en español: fases bloqueadas manualmente por el host (array de phaseIds)
  // Ejemplo: ["round_of_16", "quarter_finals"] impide avanzar y permite correcciones
  lockedPhases Json @default("[]")

  // Comentario en español: si true, nuevos miembros requieren aprobación del host/co-admin
  requireApproval Boolean @default(false)

  // Comentario en español: configuración avanzada de tipos de picks por fase (PhasePickConfig[])
  // Define qué tipos de predicciones están permitidos y sus puntos en cada fase
  // null = usa scoring preset clásico (retrocompatibilidad)
  pickTypesConfig Json?

  // Comentario en español: snapshot PROPIO del fixture del torneo (copiado al crear la pool)
  // Cuando se avanza una fase, se modifica SOLO este campo, NO la TournamentInstance
  // Esto permite que cada pool tenga su propio estado de avance independiente
  fixtureSnapshot Json?

  createdByUserId String
  createdByUser   User   @relation(fields: [createdByUserId], references: [id])

  members PoolMember[]
  invites PoolInvite[]

  createdAtUtc              DateTime                   @default(now())
  updatedAtUtc              DateTime                   @updatedAt
  predictions               Prediction[]
  matchResults              PoolMatchResult[]
  structuralPredictions     StructuralPrediction[]
  structuralPhaseResults    StructuralPhaseResult[]
  groupStandingsPredictions GroupStandingsPrediction[]
  groupStandingsResults     GroupStandingsResult[]

  @@index([tournamentInstanceId])
  @@index([createdByUserId])
}

model PoolMember {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  role   PoolMemberRole   @default(PLAYER)
  status PoolMemberStatus @default(ACTIVE)

  joinedAtUtc DateTime  @default(now())
  leftAtUtc   DateTime?

  // Comentario en español: campos para join approval workflow
  approvedByUserId String? // Quién aprobó o rechazó
  approvedAtUtc    DateTime? // Cuándo se aprobó o rechazó
  rejectionReason  String? // Razón del rechazo (opcional)

  // Comentario en español: campos para sistema de expulsión/ban
  bannedAt       DateTime? // Cuándo fue expulsado
  bannedByUserId String? // Quién lo expulsó (HOST o CO_ADMIN)
  banReason      String? // Razón de la expulsión (obligatoria)
  banExpiresAt   DateTime? // null = permanente, fecha = temporal

  @@unique([poolId, userId])
  @@index([userId])
  @@index([status])
}

model PoolInvite {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  code String @unique

  createdByUserId String
  createdByUser   User   @relation(fields: [createdByUserId], references: [id])

  maxUses Int?
  uses    Int  @default(0)

  expiresAtUtc DateTime?

  createdAtUtc DateTime @default(now())

  @@index([poolId])
}

model Prediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Comentario en español: matchId corresponde a TemplateData.matches[].id dentro del TournamentInstance snapshot
  matchId String

  // Comentario en español: estructura flexible para MVP (luego la versionamos por schema)
  pickJson Json

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, matchId])
  @@index([userId])
  @@index([poolId])
}

// Sprint 2 - Advanced Pick Types: Picks estructurales (por fase completa, no por match)
model StructuralPrediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // phaseId corresponde a TemplateData.phases[].id del TournamentInstance
  phaseId String

  // Datos del pick estructural (formato según tipo de fase)
  // Ej: { groups: [{groupId, teamIds: [...]}] } para GROUP_STANDINGS
  // Ej: { matches: [{matchId, winnerId}] } para KNOCKOUT_WINNER
  pickJson Json

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, phaseId], name: "poolId_userId_phaseId")
  @@index([userId])
  @@index([poolId])
}

model PoolMatchResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // Comentario en español: matchId corresponde al snapshot TournamentInstance.dataJson.matches[].id
  matchId String

  // Comentario en español: relación 1:N a todas las versiones publicadas (incluye erratas)
  versions PoolMatchResultVersion[] @relation("PoolMatchResultVersions")

  // Comentario en español: puntero a la versión vigente del resultado
  currentVersionId String?                 @unique
  currentVersion   PoolMatchResultVersion? @relation("CurrentPoolMatchResult", fields: [currentVersionId], references: [id])

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, matchId])
  @@index([poolId])
}

model PoolMatchResultVersion {
  id String @id @default(uuid())

  resultId String
  // Comentario en español: relación inversa (muchas versiones -> un result header)
  result   PoolMatchResult @relation("PoolMatchResultVersions", fields: [resultId], references: [id])

  // Comentario en español: relación inversa opcional para currentVersion
  currentForResult PoolMatchResult? @relation("CurrentPoolMatchResult")

  versionNumber Int
  status        ResultVersionStatus @default(PUBLISHED)

  homeGoals Int
  awayGoals Int

  // Comentario en español: goles de penalties (solo para fases eliminatorias)
  homePenalties Int?
  awayPenalties Int?

  // Comentario en español: motivo opcional cuando esto es una corrección (errata)
  reason String?

  // =========================================================================
  // AUTO RESULTS - Tracking de fuente del resultado
  // =========================================================================

  // Fuente de este resultado: HOST_MANUAL, HOST_PROVISIONAL, API_CONFIRMED, HOST_OVERRIDE
  source ResultSource @default(HOST_MANUAL)

  // Datos de API-Football (solo si source = API_CONFIRMED)
  externalFixtureId Int?  // ID del fixture en API-Football
  externalDataJson  Json? // Snapshot de la respuesta de API-Football (para auditoría)

  createdByUserId String?
  createdBy       User?   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([resultId, versionNumber])
  @@index([resultId])
  @@index([source])
}

// Sprint 2 - Advanced Pick Types: Resultados estructurales (publicados por HOST)
model StructuralPhaseResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // phaseId corresponde a TemplateData.phases[].id del TournamentInstance
  phaseId String

  // Datos del resultado estructural (mismo formato que StructuralPrediction.pickJson)
  // Ej: { groups: [{groupId, teamIds: [...]}] } para GROUP_STANDINGS
  // Ej: { matches: [{matchId, winnerId}] } para KNOCKOUT_WINNER
  resultJson Json

  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, phaseId])
  @@index([poolId])
}

// Sprint 2 - Guardado Granular: Predicciones de posiciones de grupo (una por grupo)
model GroupStandingsPrediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  phaseId String // Fase del torneo
  groupId String // ID del grupo (A, B, C, etc.)

  // Array de teamIds en orden del 1° al 4° lugar
  // Ej: ["t_A1", "t_A3", "t_A2", "t_A4"]
  teamIds String[]

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, phaseId, groupId], name: "poolId_userId_phaseId_groupId")
  @@index([poolId])
  @@index([userId])
}

// Sprint 2 - Guardado Granular: Resultados oficiales de posiciones de grupo
model GroupStandingsResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  phaseId String // Fase del torneo
  groupId String // ID del grupo (A, B, C, etc.)

  // Array de teamIds en orden oficial del 1° al 4° lugar
  teamIds String[]

  // Versión para erratas
  version Int     @default(1)
  reason  String? // Razón de la errata (obligatorio si version > 1)

  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())
  createdAtUtc   DateTime @default(now())
  updatedAtUtc   DateTime @updatedAt

  @@unique([poolId, phaseId, groupId], name: "poolId_phaseId_groupId")
  @@index([poolId])
}

// =========================================================================
// LEGAL DOCUMENTS - Sistema de versionado de documentos legales
// =========================================================================

enum LegalDocumentType {
  TERMS_OF_SERVICE
  PRIVACY_POLICY
}

model LegalDocument {
  id String @id @default(uuid())

  type    LegalDocumentType
  version String // Formato: "YYYY-MM-DD" o semver "1.0.0"

  // Contenido del documento
  title   String // Ej: "Términos de Servicio", "Política de Privacidad"
  content String @db.Text // Contenido completo en markdown

  // Resumen de cambios (para mostrar al usuario cuando hay nueva versión)
  changeSummary String? @db.Text

  // Metadata
  locale       String  @default("es") // ISO 639-1 (es, en, pt)
  isActive     Boolean @default(false) // Solo un documento activo por tipo+locale
  publishedAt  DateTime?
  effectiveAt  DateTime? // Cuándo entra en vigor (puede ser futuro)

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([type, version, locale])
  @@index([type, locale, isActive])
}

// =========================================================================
// PLATFORM SETTINGS - Configuración global de la plataforma
// Comentario en español: tabla singleton para configuración admin de emails y otros
// =========================================================================

model PlatformSettings {
  // ID fijo "singleton" para garantizar una sola fila
  id String @id @default("singleton")

  // =========================================================================
  // EMAIL TOGGLES (Admin controla)
  // Comentario en español: si false, el tipo de email NO se envía a nadie
  // =========================================================================

  emailWelcomeEnabled          Boolean @default(true) // Email de bienvenida en registro
  emailPoolInvitationEnabled   Boolean @default(true) // Notificación de invitación a pool
  emailDeadlineReminderEnabled Boolean @default(false) // Recordatorio de deadline (desactivado por defecto)
  emailResultPublishedEnabled  Boolean @default(true) // Notificación de resultado publicado
  emailPoolCompletedEnabled    Boolean @default(true) // Notificación de pool completado

  // Audit trail
  updatedAt   DateTime @updatedAt
  updatedById String? // userId del admin que hizo el último cambio
}

// =========================================================================
// DEADLINE REMINDER LOG - Tracking de recordatorios enviados
// Comentario en español: evita duplicados y permite auditoría de emails enviados
// =========================================================================

model DeadlineReminderLog {
  id String @id @default(uuid())

  poolId  String
  userId  String
  matchId String // Partido específico para el cual se envió el recordatorio

  // Información del email
  sentAt    DateTime @default(now())
  sentToEmail String

  // Resultado del envío
  success Boolean @default(true)
  error   String? // Error si falló

  // Metadata del contexto
  hoursBeforeDeadline Int // Cuántas horas antes del deadline se envió

  @@unique([poolId, userId, matchId]) // Un recordatorio por usuario/partido/pool
  @@index([poolId])
  @@index([userId])
  @@index([sentAt])
}

// =========================================================================
// AUTO RESULTS - Mapeo de partidos internos a IDs externos (API-Football)
// =========================================================================

model MatchExternalMapping {
  id String @id @default(uuid())

  tournamentInstanceId String
  tournamentInstance   TournamentInstance @relation(fields: [tournamentInstanceId], references: [id])

  // ID interno del partido (corresponde a TournamentInstance.dataJson.matches[].id)
  internalMatchId String

  // ID del fixture en API-Football
  apiFootballFixtureId Int

  // Metadata de verificación (opcional, para validar que el mapeo es correcto)
  apiFootballHomeTeamId Int?
  apiFootballAwayTeamId Int?

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([tournamentInstanceId, internalMatchId])
  @@unique([tournamentInstanceId, apiFootballFixtureId])
  @@index([apiFootballFixtureId])
}

// =========================================================================
// AUTO RESULTS - Log de sincronizaciones con API-Football
// =========================================================================

model ResultSyncLog {
  id String @id @default(uuid())

  tournamentInstanceId String
  tournamentInstance   TournamentInstance @relation(fields: [tournamentInstanceId], references: [id])

  // Metadata del job
  startedAtUtc   DateTime   @default(now())
  completedAtUtc DateTime?
  status         SyncStatus @default(RUNNING)

  // Resultados del sync
  fixturesChecked Int @default(0) // Cuántos fixtures se consultaron
  fixturesUpdated Int @default(0) // Cuántos resultados se actualizaron/crearon
  fixturesSkipped Int @default(0) // Cuántos se saltaron (ya tenían resultado, etc.)

  // Errores (array de objetos con detalles)
  errors Json?

  // Metadata de API
  apiResponseTimeMs     Int? // Tiempo de respuesta de la API en ms
  apiRateLimitRemaining Int? // Cuántos requests quedan en el rate limit

  @@index([tournamentInstanceId])
  @@index([status])
  @@index([startedAtUtc])
}

// Match Sync State - Tracks individual match sync status for smart polling
model MatchSyncState {
  id                    String   @id @default(uuid())
  tournamentInstanceId  String
  tournamentInstance    TournamentInstance @relation(fields: [tournamentInstanceId], references: [id], onDelete: Cascade)
  
  internalMatchId       String   // Match ID from dataJson
  
  // State machine: PENDING → IN_PROGRESS → AWAITING_FINISH → COMPLETED
  syncStatus            MatchSyncStatus @default(PENDING)
  
  // Timing
  kickoffUtc            DateTime
  firstCheckAtUtc       DateTime?  // kickoff + 5min
  finishCheckAtUtc      DateTime?  // kickoff + 110min
  lastCheckedAtUtc      DateTime?
  completedAtUtc        DateTime?
  
  // API response cache
  lastApiStatus         String?    // e.g., "1H", "HT", "2H", "FT"
  
  createdAtUtc          DateTime @default(now())
  updatedAtUtc          DateTime @updatedAt
  
  @@unique([tournamentInstanceId, internalMatchId])
  @@index([syncStatus])
  @@index([firstCheckAtUtc])
  @@index([finishCheckAtUtc])
}

enum MatchSyncStatus {
  PENDING           // Waiting for kickoff + 5min
  IN_PROGRESS       // Match started, waiting for finishCheckAtUtc
  AWAITING_FINISH   // Past estimated end, polling every 5min
  COMPLETED         // Match finished, never check again
  SKIPPED           // No API mapping or manual mode
}

// ==========================================
// Beta Feedback (testing period)
// ==========================================

enum BetaFeedbackType {
  BUG
  SUGGESTION
}

model BetaFeedback {
  id             String           @id @default(uuid())
  type           BetaFeedbackType
  message        String
  imageBase64    String?          // Screenshot as base64 string
  wantsContact   Boolean          @default(false)
  contactName    String?
  phoneNumber    String?

  // User info (optional - may be anonymous)
  userId         String?
  userEmail      String?

  // Context
  currentUrl     String?
  userAgent      String?

  createdAtUtc   DateTime         @default(now())

  @@index([type])
  @@index([createdAtUtc])
}
