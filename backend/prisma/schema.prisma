datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum PlatformRole {
  ADMIN
  HOST
  PLAYER
}

enum UserStatus {
  ACTIVE
  DISABLED
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

model User {
  id           String       @id @default(uuid())
  email        String       @unique
  username     String       @unique
  displayName  String
  passwordHash String
  platformRole PlatformRole @default(PLAYER)
  status       UserStatus   @default(ACTIVE)

  // Comentario en español: campos de perfil del usuario
  firstName   String?
  lastName    String?
  dateOfBirth DateTime?
  gender      Gender?
  bio         String?   @db.VarChar(200)
  country     String?   @db.VarChar(2) // ISO 3166-1 alpha-2 (MX, CO, ES, etc.)
  timezone    String? // IANA timezone (ej: "America/Mexico_City", "Europe/Madrid")

  // Comentario en español: tracking de cambio de username (máximo 1 cada 30 días)
  lastUsernameChangeAt DateTime?

  // Comentario en español: token de reset de password (válido 1 hora)
  resetToken          String?
  resetTokenExpiresAt DateTime?

  // Comentario en español: Google OAuth ID (único por usuario de Google)
  googleId String? @unique

  createdAtUtc DateTime     @default(now())
  updatedAtUtc DateTime     @updatedAt
  predictions  Prediction[]

  poolsCreated              Pool[]
  poolMemberships           PoolMember[]
  poolInvitesCreated        PoolInvite[]
  resultVersionsCreated     PoolMatchResultVersion[]
  structuralPredictions     StructuralPrediction[]
  structuralPhaseResults    StructuralPhaseResult[]
  groupStandingsPredictions GroupStandingsPrediction[]
  groupStandingsResults     GroupStandingsResult[]

  @@index([username])
  @@index([resetToken])
  @@index([googleId])
}

model AuditEvent {
  id           String   @id @default(uuid())
  createdAtUtc DateTime @default(now())

  actorUserId String?
  action      String
  entityType  String?
  entityId    String?
  poolId      String?

  dataJson  Json?
  ip        String?
  userAgent String?
}

enum TemplateStatus {
  DRAFT
  PUBLISHED
  DEPRECATED
}

enum TemplateVersionStatus {
  DRAFT
  PUBLISHED
  DEPRECATED
}

model TournamentTemplate {
  id          String  @id @default(uuid())
  key         String  @unique // ej: "worldcup_2026"
  name        String
  description String?

  status TemplateStatus @default(DRAFT)

  // Comentario en español: referencia rápida a la versión publicada actual (si existe)
  currentPublishedVersionId String?                    @unique
  currentPublishedVersion   TournamentTemplateVersion? @relation("CurrentPublishedVersion", fields: [currentPublishedVersionId], references: [id])

  versions TournamentTemplateVersion[]

  // Comentario en español: instancias creadas desde este template
  instances TournamentInstance[]

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt
}

model TournamentTemplateVersion {
  id         String             @id @default(uuid())
  templateId String
  template   TournamentTemplate @relation(fields: [templateId], references: [id])

  // Comentario en español: relación inversa opcional para currentPublishedVersion
  currentForTemplate TournamentTemplate? @relation("CurrentPublishedVersion")

  // Comentario en español: instancias creadas a partir de esta versión publicada
  instances TournamentInstance[] @relation("InstanceSourceVersion")

  versionNumber Int
  status        TemplateVersionStatus @default(DRAFT)

  dataJson       Json
  publishedAtUtc DateTime?

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([templateId, versionNumber])
}

enum TournamentInstanceStatus {
  DRAFT
  ACTIVE
  COMPLETED
  ARCHIVED
}

model TournamentInstance {
  id String @id @default(uuid())

  templateId String
  template   TournamentTemplate @relation(fields: [templateId], references: [id])

  templateVersionId String
  templateVersion   TournamentTemplateVersion @relation("InstanceSourceVersion", fields: [templateVersionId], references: [id])

  name   String
  status TournamentInstanceStatus @default(DRAFT)

  // Comentario en español: snapshot congelado del torneo “real” (copiado desde la versión publicada)
  dataJson Json

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt
  pools        Pool[]

  @@index([templateId])
  @@index([templateVersionId])
}

enum PoolVisibility {
  PRIVATE
  PUBLIC
}

enum PoolStatus {
  DRAFT
  ACTIVE
  COMPLETED
  ARCHIVED
}

enum PoolMemberRole {
  HOST
  CO_ADMIN
  PLAYER
}

enum PoolMemberStatus {
  PENDING_APPROVAL
  ACTIVE
  LEFT
  BANNED
}

enum ResultVersionStatus {
  PUBLISHED
}

model Pool {
  id String @id @default(uuid())

  tournamentInstanceId String
  tournamentInstance   TournamentInstance @relation(fields: [tournamentInstanceId], references: [id])

  name        String
  description String?

  visibility PoolVisibility @default(PRIVATE)
  status     PoolStatus     @default(DRAFT)

  // Comentario en español: zona horaria del pool (IANA), ej: "America/Bogota"
  timeZone String @default("UTC")

  // Comentario en español: cierre de pronósticos X minutos antes del kickoff
  deadlineMinutesBeforeKickoff Int    @default(10)
  scoringPresetKey             String @default("CLASSIC")

  // Comentario en español: habilita avance automático de fases cuando se completan resultados
  autoAdvanceEnabled Boolean @default(true)

  // Comentario en español: fases bloqueadas manualmente por el host (array de phaseIds)
  // Ejemplo: ["round_of_16", "quarter_finals"] impide avanzar y permite correcciones
  lockedPhases Json @default("[]")

  // Comentario en español: si true, nuevos miembros requieren aprobación del host/co-admin
  requireApproval Boolean @default(false)

  // Comentario en español: configuración avanzada de tipos de picks por fase (PhasePickConfig[])
  // Define qué tipos de predicciones están permitidos y sus puntos en cada fase
  // null = usa scoring preset clásico (retrocompatibilidad)
  pickTypesConfig Json?

  // Comentario en español: snapshot PROPIO del fixture del torneo (copiado al crear la pool)
  // Cuando se avanza una fase, se modifica SOLO este campo, NO la TournamentInstance
  // Esto permite que cada pool tenga su propio estado de avance independiente
  fixtureSnapshot Json?

  createdByUserId String
  createdByUser   User   @relation(fields: [createdByUserId], references: [id])

  members PoolMember[]
  invites PoolInvite[]

  createdAtUtc           DateTime                @default(now())
  updatedAtUtc           DateTime                @updatedAt
  predictions            Prediction[]
  matchResults           PoolMatchResult[]
  structuralPredictions     StructuralPrediction[]
  structuralPhaseResults    StructuralPhaseResult[]
  groupStandingsPredictions GroupStandingsPrediction[]
  groupStandingsResults     GroupStandingsResult[]

  @@index([tournamentInstanceId])
  @@index([createdByUserId])
}

model PoolMember {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  role   PoolMemberRole   @default(PLAYER)
  status PoolMemberStatus @default(ACTIVE)

  joinedAtUtc DateTime  @default(now())
  leftAtUtc   DateTime?

  // Comentario en español: campos para join approval workflow
  approvedByUserId String? // Quién aprobó o rechazó
  approvedAtUtc    DateTime? // Cuándo se aprobó o rechazó
  rejectionReason  String? // Razón del rechazo (opcional)

  // Comentario en español: campos para sistema de expulsión/ban
  bannedAt       DateTime? // Cuándo fue expulsado
  bannedByUserId String? // Quién lo expulsó (HOST o CO_ADMIN)
  banReason      String? // Razón de la expulsión (obligatoria)
  banExpiresAt   DateTime? // null = permanente, fecha = temporal

  @@unique([poolId, userId])
  @@index([userId])
  @@index([status])
}

model PoolInvite {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  code String @unique

  createdByUserId String
  createdByUser   User   @relation(fields: [createdByUserId], references: [id])

  maxUses Int?
  uses    Int  @default(0)

  expiresAtUtc DateTime?

  createdAtUtc DateTime @default(now())

  @@index([poolId])
}

model Prediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Comentario en español: matchId corresponde a TemplateData.matches[].id dentro del TournamentInstance snapshot
  matchId String

  // Comentario en español: estructura flexible para MVP (luego la versionamos por schema)
  pickJson Json

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, matchId])
  @@index([userId])
  @@index([poolId])
}

// Sprint 2 - Advanced Pick Types: Picks estructurales (por fase completa, no por match)
model StructuralPrediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // phaseId corresponde a TemplateData.phases[].id del TournamentInstance
  phaseId String

  // Datos del pick estructural (formato según tipo de fase)
  // Ej: { groups: [{groupId, teamIds: [...]}] } para GROUP_STANDINGS
  // Ej: { matches: [{matchId, winnerId}] } para KNOCKOUT_WINNER
  pickJson Json

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, phaseId], name: "poolId_userId_phaseId")
  @@index([userId])
  @@index([poolId])
}

model PoolMatchResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // Comentario en español: matchId corresponde al snapshot TournamentInstance.dataJson.matches[].id
  matchId String

  // Comentario en español: relación 1:N a todas las versiones publicadas (incluye erratas)
  versions PoolMatchResultVersion[] @relation("PoolMatchResultVersions")

  // Comentario en español: puntero a la versión vigente del resultado
  currentVersionId String?                 @unique
  currentVersion   PoolMatchResultVersion? @relation("CurrentPoolMatchResult", fields: [currentVersionId], references: [id])

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, matchId])
  @@index([poolId])
}

model PoolMatchResultVersion {
  id String @id @default(uuid())

  resultId String
  // Comentario en español: relación inversa (muchas versiones -> un result header)
  result   PoolMatchResult @relation("PoolMatchResultVersions", fields: [resultId], references: [id])

  // Comentario en español: relación inversa opcional para currentVersion
  currentForResult PoolMatchResult? @relation("CurrentPoolMatchResult")

  versionNumber Int
  status        ResultVersionStatus @default(PUBLISHED)

  homeGoals Int
  awayGoals Int

  // Comentario en español: goles de penalties (solo para fases eliminatorias)
  homePenalties Int?
  awayPenalties Int?

  // Comentario en español: motivo opcional cuando esto es una corrección (errata)
  reason String?

  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([resultId, versionNumber])
  @@index([resultId])
}

// Sprint 2 - Advanced Pick Types: Resultados estructurales (publicados por HOST)
model StructuralPhaseResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  // phaseId corresponde a TemplateData.phases[].id del TournamentInstance
  phaseId String

  // Datos del resultado estructural (mismo formato que StructuralPrediction.pickJson)
  // Ej: { groups: [{groupId, teamIds: [...]}] } para GROUP_STANDINGS
  // Ej: { matches: [{matchId, winnerId}] } para KNOCKOUT_WINNER
  resultJson Json

  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, phaseId])
  @@index([poolId])
}

// Sprint 2 - Guardado Granular: Predicciones de posiciones de grupo (una por grupo)
model GroupStandingsPrediction {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  phaseId String // Fase del torneo
  groupId String // ID del grupo (A, B, C, etc.)

  // Array de teamIds en orden del 1° al 4° lugar
  // Ej: ["t_A1", "t_A3", "t_A2", "t_A4"]
  teamIds String[]

  createdAtUtc DateTime @default(now())
  updatedAtUtc DateTime @updatedAt

  @@unique([poolId, userId, phaseId, groupId], name: "poolId_userId_phaseId_groupId")
  @@index([poolId])
  @@index([userId])
}

// Sprint 2 - Guardado Granular: Resultados oficiales de posiciones de grupo
model GroupStandingsResult {
  id String @id @default(uuid())

  poolId String
  pool   Pool   @relation(fields: [poolId], references: [id])

  phaseId String // Fase del torneo
  groupId String // ID del grupo (A, B, C, etc.)

  // Array de teamIds en orden oficial del 1° al 4° lugar
  teamIds String[]

  // Versión para erratas
  version Int    @default(1)
  reason  String? // Razón de la errata (obligatorio si version > 1)

  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id])

  publishedAtUtc DateTime @default(now())
  createdAtUtc   DateTime @default(now())
  updatedAtUtc   DateTime @updatedAt

  @@unique([poolId, phaseId, groupId], name: "poolId_phaseId_groupId")
  @@index([poolId])
}
